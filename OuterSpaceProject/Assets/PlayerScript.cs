using Unity.Burst.CompilerServices;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

public enum PlayerClass
{
    Melee = 0,
    Ranged = 3,
    Magic = 6,
}

public class PlayerScript : MonoBehaviour
{
    [Header("Class")]
    public PlayerClass Class;

    [Header("Components")]
    public Rigidbody rb;
    public GameObject sword;
    public GameObject wheel;
    public Animator animator;
    public GameObject mesh;
    public Material crystalMaterial;
    public Material swordMaterial;
    public Camera cam;
    public HealthManager healthManager;
    [Header("Movement")]
    public float speed;
    [Range(0.75f, 1f)]
    public float brakeSpeed;
    public float rotationSpeed;
    [Range(1, 360)]
    public int rotationSnaps;
    [SerializeField] private float snapDistance = 0.5f;
    public LayerMask ground;

    public bool isHit;
    [Header("Health")]
    public float hitCooldown;
    [HideInInspector]
    public float hitTimer;
    public float maxhp = 100;
    public float hp = 100;

    public float maxstamina = 100;
    public float stamina = 100;
    public bool shouldRegenStamina;
    public bool canUseStamina;
    public float staminaRegainSpeed;
    //[HideInInspector]
    public float staminaMultiplier = 1;

    public float defence;
    [ColorUsage(false, true)]
    public Color hitColor;
    [ColorUsage(false, true)]
    public Color defaultColor;

    [Header("Damage")]
    public float knockback;
    public float damage;
    public float armorPenetration = 0;
    [HideInInspector]
    public bool isSwinging;
    [HideInInspector]
    float prev_RightTrigger;
    float prev_LeftTrigger;

    [Header("Dash")]
    public float dashForce;
    public float dashCooldown;
    private bool isDashing;
    private float dashTimer;
    private Vector2 lastMoveDir;
    public float dashStaminaUsage;

    [Header("Other")]
    public GameObject forceField;
    public float shieldStaminaDrain;

    // Update is called once per frame
    void Update()
    {
        healthManager.maxHealth = maxhp;
        healthManager.health = hp;
        healthManager.maxStamina = maxstamina;
        healthManager.stamina = stamina;
        healthManager.isDamaged = isHit;

        if (stamina <= 0)
        {
            forceField.SetActive(false);
            shouldRegenStamina = true;
            canUseStamina = false;
            isHit = true;
            hitTimer = Mathf.Infinity;
        } else
        {
            shouldRegenStamina = true;
        }

        if (canUseStamina == false)
        {
            forceField.SetActive(false);
            shouldRegenStamina = true;
            canUseStamina = false;
            isHit = true;
            hitTimer = Mathf.Infinity;
            stamina += Time.deltaTime * staminaRegainSpeed * staminaMultiplier * 3;
        }

        if (stamina >= maxstamina && canUseStamina == false)
        {
            canUseStamina = true;
            isHit = false;
            hitTimer = 0;
        }

        if (hp <= 0)
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
        }

        if (stamina < 0)
        {
            stamina = 0;
        }
        if (stamina > maxstamina)
        {
            stamina = maxstamina;
        }

        if (shouldRegenStamina)
        {
            stamina += Time.deltaTime * staminaRegainSpeed * staminaMultiplier;
        }

        // Controller rotation Generated by ChatGPT
        float horizontalInput = Input.GetAxisRaw("RightJoystickHorizontal");
        float verticalInput = Input.GetAxisRaw("RightJoystickVertical");

        //Debug.Log(new Vector2(horizontalInput, verticalInput));

        // Check if the joystick input is significant enough to rotate the GameObject.
        if (Mathf.Abs(horizontalInput) > 0.1f || Mathf.Abs(verticalInput) > 0.1f)
        {
            // Calculate the angle between the joystick input and the forward direction of the GameObject.
            Vector3 inputDirection = new Vector3(horizontalInput, 0f, verticalInput).normalized;
            float angle = Mathf.Atan2(inputDirection.x, inputDirection.z) * Mathf.Rad2Deg;

            // Modify the angle to snap to rotationSnaps amount of rotations
            //float newAngle = ((int)angle / (360 / rotationSnaps)) * (int)(360 / rotationSnaps);

            // Calculate the target rotation as a local rotation around the Y-axis.
            Quaternion targetRotation = Quaternion.Euler(0f, angle + 90, 0f);

            // Apply the rotation to the GameObject's local rotation using Slerp.
            transform.localRotation = Quaternion.Lerp(transform.localRotation, targetRotation, rotationSpeed * Time.deltaTime);
        }

        //MouseRotation();

        
        if (animator.GetCurrentAnimatorStateInfo(0).IsName("SwordSwing"))
        {
            isSwinging = true;
        } else
        {
            isSwinging = false;
        }

        if (isHit)
        {
            hitTimer -= Time.deltaTime;
            if (hitTimer < 0)
            {
                isHit = false;
            }
            crystalMaterial.color = hitColor;
            swordMaterial.color = defaultColor;
        } else
        {
            crystalMaterial.color = defaultColor;
            swordMaterial.color = hitColor;

            if (Input.GetMouseButtonDown(0) || Input.GetAxisRaw("RightTrigger") > 0.9f && Input.GetAxisRaw("RightTrigger") != prev_RightTrigger)
            {
                if (forceField.activeSelf == false && canUseStamina)
                {
                    animator.SetTrigger("Swing");
                }
            }
        }

        prev_RightTrigger = Input.GetAxisRaw("RightTrigger");

        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");

        if (horizontal != 0 || vertical != 0)
        {
            lastMoveDir.x = horizontal;
            lastMoveDir.y = vertical;
        }

        float leftTrigger = Input.GetAxisRaw("LeftTrigger");


        // Check if the dash button is pressed and the dash is not on cooldown.
        if (leftTrigger > 0.9f && leftTrigger > prev_LeftTrigger || Input.GetKeyDown(KeyCode.LeftShift) && !isDashing && dashTimer <= 0f)
        {
            if (stamina > dashStaminaUsage / 2 && canUseStamina)
            {
                // Get the last movement direction.
                Vector3 dashDirection = new Vector3(lastMoveDir.x, 0f, lastMoveDir.y).normalized;

                // Check if there was any movement before dashing.
                if (dashDirection != Vector3.zero)
                {
                    // Apply the dash force in the movement direction.
                    rb.AddForce(dashDirection * dashForce, ForceMode.Impulse);

                    // Start the dash cooldown.
                    dashTimer = dashCooldown;

                    // Set the dashing flag to true.
                    isDashing = true;

                    stamina -= dashStaminaUsage;
                }
            }
        }

        // ... Other code ...

        // Reduce the dash timer and reset the dashing flag when the cooldown is over.
        if (isDashing)
        {
            dashTimer -= Time.deltaTime;
            if (dashTimer <= 0f)
            {
                isDashing = false;
            }
        }

        prev_LeftTrigger = leftTrigger;

        if (Input.GetAxisRaw("DpadHorizontal") <= -0.5f)
        {
            ZaWarudo(0.0000001f);
        }
        if (Input.GetAxisRaw("DpadHorizontal") >= 0.5f)
        {
            ZaWarudo(1f);
        }
    }

    void ZaWarudo(float timescale)
    {
        Time.timeScale = timescale;
    }

    private void FixedUpdate()
    {
        
        RaycastHit hit;
        // Cast a ray downwards from the GameObject's position
        if (Physics.BoxCast(transform.position + new Vector3(0, 5, 0), new Vector3(0.5f, 0.5f, 0.5f), Vector3.down, out hit, Quaternion.identity, 100f, ground)) 
        {
            // Calculate the new position based on the hit point
            Vector3 newPosition = new Vector3(0, hit.point.y + snapDistance, 0); // Adjust the 0.5f offset if needed

            //Debug.Log(newPosition);

            // Update the GameObject's position
            transform.position = new Vector3(transform.position.x, newPosition.y, transform.position.z);
        }

        float vertical = 0;
        float horizontal = 0;

        if (isHit)
        {
            vertical = Input.GetAxisRaw("Vertical") * (speed / 2);
            horizontal = Input.GetAxisRaw("Horizontal") * (speed / 2);
        } else
        {
            vertical = Input.GetAxisRaw("Vertical") * speed;
            horizontal = Input.GetAxisRaw("Horizontal") * speed;
        }

        if (stamina <= 10)
        {
            vertical /= 2;
            horizontal /= 2;
        }

        if (isDashing)
        {
            vertical = 0;
            horizontal = 0;
        }

        if (Input.GetButton("ShieldButton") && stamina > 0 && canUseStamina)
        {
            forceField.SetActive(true);
            stamina -= Time.deltaTime * shieldStaminaDrain;
            vertical = 0;
            horizontal = 0;
            shouldRegenStamina = false;
        }
        else
        {
            forceField.SetActive(false);
            shouldRegenStamina = true;
        }

        // str = horizontal.ToString() + ", " + vertical.ToString();
        //Debug.Log(str);

        if (horizontal > 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 45 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -45 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal > 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 135 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -135 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal > 0f && vertical == 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -90, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical == 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 90, transform.rotation.eulerAngles.z);
        }
        else if (horizontal == 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 0, transform.rotation.eulerAngles.z);
        }
        else if (horizontal == 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 180, transform.rotation.eulerAngles.z);
        }

        //x axis movement
        //transform.position += new Vector3(horizontal, 0, 0) * Time.deltaTime;

        if (vertical != 0)
        {
            rb.velocity = new Vector3(rb.velocity.x, rb.velocity.y, vertical);
        }
        else
        {
            rb.velocity = new Vector3(rb.velocity.x, rb.velocity.y, rb.velocity.z * brakeSpeed);
        }
        if (horizontal != 0)
        {
            rb.velocity = new Vector3(horizontal, rb.velocity.y, rb.velocity.z);
        }
        else
        {
            rb.velocity = new Vector3(rb.velocity.x * brakeSpeed, rb.velocity.y, rb.velocity.z);
        }
        //transform.localPosition += new Vector3(0, 0, vertical) * Time.deltaTime;
    }
}
