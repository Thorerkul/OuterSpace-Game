using UnityEditor;
using UnityEngine;
using static UnityEditor.Searcher.SearcherWindow.Alignment;

public class PlayerScript : MonoBehaviour
{
    [Header("Components")]
    public Rigidbody rb;
    public GameObject sword;
    public GameObject wheel;
    public Animator animator;
    public GameObject mesh;
    public Material crystalMaterial;
    public Material swordMaterial;
    public Camera cam;
    [Header("Movement")]
    public float speed;
    [Range(0.75f, 1f)]
    public float brakeSpeed;
    public float rotationSpeed;
    [Range(1, 360)]
    public int rotationSnaps;

    [HideInInspector]
    public bool isHit;
    [Header("Health")]
    public float hitCooldown;
    [HideInInspector]
    public float hitTimer;
    public float maxhp = 100;
    public float hp = 100;
    public float defence;
    [ColorUsage(false, true)]
    public Color hitColor;
    [ColorUsage(false, true)]
    public Color defaultColor;

    [Header("Damage")]
    public float knockback;
    public float damage;
    public float armorPenetration = 0;
    [HideInInspector]
    public bool isSwinging;
    [HideInInspector]
    float prev_RightTrigger;
    float prev_LeftTrigger;

    [Header("Dash")]
    public float dashForce;
    public float dashCooldown;
    private bool isDashing;
    private float dashTimer;
    private Vector2 lastMoveDir;

    // Update is called once per frame
    void Update()
    {
        // Controller rotation Generated by ChatGPT
        float horizontalInput = Input.GetAxisRaw("RightJoystickHorizontal");
        float verticalInput = Input.GetAxisRaw("RightJoystickVertical");

        //Debug.Log(new Vector2(horizontalInput, verticalInput));

        // Check if the joystick input is significant enough to rotate the GameObject.
        if (Mathf.Abs(horizontalInput) > 0.1f || Mathf.Abs(verticalInput) > 0.1f)
        {
            // Calculate the angle between the joystick input and the forward direction of the GameObject.
            Vector3 inputDirection = new Vector3(horizontalInput, 0f, verticalInput).normalized;
            float angle = Mathf.Atan2(inputDirection.x, inputDirection.z) * Mathf.Rad2Deg;

            // Modify the angle to snap to rotationSnaps amount of rotations
            //float newAngle = ((int)angle / (360 / rotationSnaps)) * (int)(360 / rotationSnaps);

            // Calculate the target rotation as a local rotation around the Y-axis.
            Quaternion targetRotation = Quaternion.Euler(0f, angle + 90, 0f);

            // Apply the rotation to the GameObject's local rotation using Slerp.
            transform.localRotation = Quaternion.Lerp(transform.localRotation, targetRotation, rotationSpeed * Time.deltaTime);
        }

        //MouseRotation();

        
        if (animator.GetCurrentAnimatorStateInfo(0).IsName("SwordSwing"))
        {
            isSwinging = true;
        } else
        {
            isSwinging = false;
        }

        if (isHit)
        {
            hitTimer -= Time.deltaTime;
            if (hitTimer < 0)
            {
                isHit = false;
            }
            crystalMaterial.color = hitColor;
            swordMaterial.color = defaultColor;
        } else
        {
            crystalMaterial.color = defaultColor;
            swordMaterial.color = hitColor;

            if (Input.GetMouseButtonDown(0) || Input.GetAxisRaw("RightTrigger") > 0.9f && Input.GetAxisRaw("RightTrigger") != prev_RightTrigger)
            {
                animator.SetTrigger("Swing");
            }
        }

        prev_RightTrigger = Input.GetAxisRaw("RightTrigger");

        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");

        if (horizontal != 0 || vertical != 0)
        {
            lastMoveDir.x = horizontal;
            lastMoveDir.y = vertical;
        }

        float leftTrigger = Input.GetAxisRaw("LeftTrigger");


        // Check if the dash button is pressed and the dash is not on cooldown.
        if (leftTrigger > 0.9f && leftTrigger > prev_LeftTrigger || Input.GetKeyDown(KeyCode.LeftShift) && !isDashing && dashTimer <= 0f)
        {
            // Get the last movement direction.
            Vector3 dashDirection = new Vector3(lastMoveDir.x, 0f, lastMoveDir.y).normalized;

            // Check if there was any movement before dashing.
            if (dashDirection != Vector3.zero)
            {
                // Apply the dash force in the movement direction.
                rb.AddForce(dashDirection * dashForce, ForceMode.Impulse);

                // Start the dash cooldown.
                dashTimer = dashCooldown;

                // Set the dashing flag to true.
                isDashing = true;
            }
        }

        // ... Other code ...

        // Reduce the dash timer and reset the dashing flag when the cooldown is over.
        if (isDashing)
        {
            dashTimer -= Time.deltaTime;
            if (dashTimer <= 0f)
            {
                isDashing = false;
            }
        }

        prev_LeftTrigger = leftTrigger;
    }

    void MouseRotation()
    {
        float horizontal = Input.GetAxis("Mouse X");
        float vertical = Input.GetAxis("Mouse Y");

        Vector2 mouseDir = new Vector2(horizontal, vertical);

        Vector2 direction = new Vector2(Mathf.Clamp(mouseDir.x, -1f, 1f), Mathf.Clamp(mouseDir.x, -1f, 1f));

        if (mouseDir.x != 0 || mouseDir.y != 0)
        {
            // Calculate the angle in degrees to the given direction.
            float angle = Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg;

            LookAtDirection(this.gameObject, direction);
        }

    }

    void LookAtDirection(GameObject gameObject, Vector2 direction)
    {
        // Calculate the angle in degrees to the given direction.
        float angle = Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg;

        // Set the GameObject's rotation to point in the calculated direction on its local Y-axis.
        gameObject.transform.localRotation = Quaternion.Euler(0f, -angle, 0f);
    }

    private void FixedUpdate()
    {
        float vertical = 0;
        float horizontal = 0;

        if (isHit)
        {
            vertical = Input.GetAxisRaw("Vertical") * (speed / 2);
            horizontal = Input.GetAxisRaw("Horizontal") * (speed / 2);
        } else
        {
            vertical = Input.GetAxisRaw("Vertical") * speed;
            horizontal = Input.GetAxisRaw("Horizontal") * speed;
        }

        if (isDashing)
        {
            vertical = 0;
            horizontal = 0;
        }

        // str = horizontal.ToString() + ", " + vertical.ToString();
        //Debug.Log(str);

        if (horizontal > 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 45 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -45 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal > 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 135 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -135 + 180, transform.rotation.eulerAngles.z);
        }
        else if (horizontal > 0f && vertical == 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, -90, transform.rotation.eulerAngles.z);
        }
        else if (horizontal < 0f && vertical == 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 90, transform.rotation.eulerAngles.z);
        }
        else if (horizontal == 0f && vertical < 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 0, transform.rotation.eulerAngles.z);
        }
        else if (horizontal == 0f && vertical > 0)
        {
            wheel.transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles.x, 180, transform.rotation.eulerAngles.z);
        }

        //x axis movement
        //transform.position += new Vector3(horizontal, 0, 0) * Time.deltaTime;

        if (vertical != 0)
        {
            rb.velocity = new Vector3(rb.velocity.x, 0, vertical);
        }
        else
        {
            rb.velocity = new Vector3(rb.velocity.x, 0, rb.velocity.z * brakeSpeed);
        }
        if (horizontal != 0)
        {
            rb.velocity = new Vector3(horizontal, 0, rb.velocity.z);
        }
        else
        {
            rb.velocity = new Vector3(rb.velocity.x * brakeSpeed, 0, rb.velocity.z);
        }
        //transform.localPosition += new Vector3(0, 0, vertical) * Time.deltaTime;
    }
}
